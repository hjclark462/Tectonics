// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InitSeed
#pragma kernel JumpFill
#pragma kernel TestColours

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Source;
RWTexture2D<float4> Result;

struct PointData
{
	int2 pixel;
	float elevation;
	int plate;
	int plateType;
	float distance;
	int2 direction;
};

RWStructuredBuffer<PointData> points;
StructuredBuffer<float4> colours;
int width;
int height;
int step;

// Clamps the flood fill so that it won't overflow the bounds of the RenderTexture
uint2 MaintainBounds(uint2 pix)
{
	return uint2(clamp(pix.x, 0, width), clamp(pix.y, 0, height));	
}

void FindMinimumDistance(float2 current, float3 target, inout float4 minInfo)
{
	if (target.z > 0)
	{
		float distance = dot(current - target.xy, current - target.xy);
		if (distance < minInfo.w)
		{
			minInfo = float4(target, distance);
		}
	}
}

[numthreads(1, 1, 1)]
void InitSeed(uint3 id : SV_DispatchThreadID)
{
	int2 initSeedPos = points[id.x].pixel;
	uint px = uint(initSeedPos.x);
	uint py = uint(initSeedPos.y);
	Source[uint2(px, py)] = float4(px, py, id.x + 1, 1);
}

[numthreads(8, 8, 1)]
void JumpFill(uint3 id : SV_DispatchThreadID)
{
	float4 minInfo = float4(0, 0, 0, 999999);
	FindMinimumDistance(id.xy, Source[id.xy].xyz, minInfo);
	FindMinimumDistance(id.xy, Source[MaintainBounds(id.xy + uint2(-step, -step))].xyz, minInfo);
	FindMinimumDistance(id.xy, Source[MaintainBounds(id.xy + uint2(-step, step))].xyz, minInfo);
	FindMinimumDistance(id.xy, Source[MaintainBounds(id.xy + uint2(-step, 0))].xyz, minInfo);
	FindMinimumDistance(id.xy, Source[MaintainBounds(id.xy + uint2(0, -step))].xyz, minInfo);
	FindMinimumDistance(id.xy, Source[MaintainBounds(id.xy + uint2(0, step))].xyz, minInfo);
	FindMinimumDistance(id.xy, Source[MaintainBounds(id.xy + uint2(step, -step))].xyz, minInfo);
	FindMinimumDistance(id.xy, Source[MaintainBounds(id.xy + uint2(step, 0))].xyz, minInfo);
	FindMinimumDistance(id.xy, Source[MaintainBounds(id.xy + uint2(step, step))].xyz, minInfo);
	Result[id.xy] = minInfo;
}

[numthreads(8, 8, 1)]
void TestColours(uint3 id : SV_DispatchThreadID)
{
	float4 info = Source[id.xy];
	if (info.w < 10)
	{
		Result[id.xy] = float4(1, 0, 0, 1);
	}
	else
	{
		uint seedID = info.z;
		Result[id.xy] = float4(colours[seedID-1]);
	}
}