// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InitSeed
#pragma kernel JumpFill
#pragma kernel TestColours

struct PointData
{
	int2 pixel;
	float elevation;
	int plate;
	int plateType;
	float distance;
	int2 direction;
};

RWTexture2D<float4> Source;
RWTexture2D<float4> Result;
RWStructuredBuffer<PointData> plates;
RWStructuredBuffer<PointData> points;
StructuredBuffer<float4> colours;
int width;
int height;
int step;

// Clamps the flood fill so that it won't overflow the bounds of the RenderTexture
uint2 MaintainBounds(uint2 p)
{
	uint x = clamp(p.x, 0, width);
	uint y = clamp(p.y, 0, height)
	return uint2(x, y);	
}

// When this shit works it works
void FindClosestPlate(float2 current, float3 target, inout float4 minInfo)
{
	if (target.z > 0)
	{
		float distance = dot(current - target.xy, current - target.xy);
		if (distance < minInfo.w)
		{
			minInfo = float4(target, distance);
		}
	}
}

[numthreads(1, 1, 1)]
void InitSeed(uint3 id : SV_DispatchThreadID)
{
	int2 initSeedPos = plates[id.x].pixel;
	uint px = uint(initSeedPos.x);
	uint py = uint(initSeedPos.y);
	Source[uint2(px, py)] = float4(px, py, id.x + 1, 1);
}

[numthreads(8, 8, 1)]
void JumpFill(uint3 id : SV_DispatchThreadID)
{
	float4 minInfo = float4(0, 0, 0, 999999);

	FindClosestPlate(id.xy, Source[id.xy].xyz, minInfo);

	FindClosestPlate(id.xy, Source[ MaintainBounds(id.xy + uint2(-step, -step)) ].xyz, minInfo);

	FindClosestPlate(id.xy, Source[ MaintainBounds(id.xy + uint2(-step, step)) ].xyz, minInfo);

	FindClosestPlate(id.xy, Source[ MaintainBounds(id.xy + uint2(-step, 0)) ].xyz, minInfo);

	FindClosestPlate(id.xy, Source[ MaintainBounds(id.xy + uint2(0, -step)) ].xyz, minInfo);

	FindClosestPlate(id.xy, Source[ MaintainBounds(id.xy + uint2(0, step)) ].xyz, minInfo);

	FindClosestPlate(id.xy, Source[ MaintainBounds(id.xy + uint2(step, -step)) ].xyz, minInfo);

	FindClosestPlate(id.xy, Source[ MaintainBounds(id.xy + uint2(step, 0)) ].xyz, minInfo);

	FindClosestPlate(id.xy, Source[ MaintainBounds(id.xy + uint2(step, step)) ].xyz, minInfo);

	Result[id.xy] = minInfo;
}

[numthreads(8, 8, 1)]
void TestColours(uint3 id : SV_DispatchThreadID)
{
	float4 info = Source[id.xy];
	if (info.w < 10)
	{
		// render the seed that the flood 
		Result[id.xy] = float4(1, 0, 0, 1);
	}
	else
	{
		uint seedID = info.z;
		Result[id.xy] = float4(colours[seedID-1]);
	}
}